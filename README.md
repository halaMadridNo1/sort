# sort
排序   设计模式
设计模式

一.工厂模式

	提供创建对象的最佳方式,不暴露客户端的创建逻辑,通过使用一个人共同的接口来指向新创建的对象

	应用实列:hibernate更换数据库只需要换方言和驱动

	优点:

		1.调用者想要创建对象,只需要知道名称就可以了

		2.扩展性好,要增加一个产品,只要扩展一个工厂类就好了

		3.屏蔽产品具体实现,调用者只关心产品的接口

	缺点: 增加系统复杂度

	使用场景:

		日志记录器.数据库访问

二.抽象工厂模式

	围绕一个超级工厂创建其他工厂

	优点:

		当一个产品中的多个对象被设计成一起工作时,保证客户端只使用同一产品族中的对象

	缺点:

		产品扩展困难

三.单列模式

	保证一个类只有一个实列,并提供一个访问的全局访问点,主要解决实用类频繁的创建与销毁

	优点:

		在内存中只有一个实列,减少内存开销,避免对资源的多重占用

	缺点:

		没有接口,与单一原则冲突,只关心内部逻辑,不关心外部实列化

	使用场景: web计数器,创建一个对象需要消耗资源多,IO/数据库连接

	多种实现方式:

		1.懒汉模式(线程不安全)

			被懒加载初始化,不支持多线程,没有加锁synchronized

		2.懒汉(线程安全)

			优点:第一次调用被初始化,避免内存浪费

			缺点:必须加锁才能保证单列,会影响效率

		3.饿汉式(线程安全)

			未初始化,容易产生垃圾对象,没有加锁,效率高,浪费内存

		4.双重校验锁(线程安全)

			在多线程下能够保持高性能

		5.静态内部类(线程安全)

		6.枚举

四.适配器模式

	将一个类的接口转化为客户希望的另一个接口,使原本由于接口不兼容而不能再一起工作的哪些类可以在一起工作

	在系统需要现有的类,而此类的接口不符合满足的时候,通过接口转换将一个类插入另一个类中

	优点:

		可以让两个没有关联的类一起运行,提高类的复用,增加类的透明度

	缺点:

		不适合过多使用

五.装饰器模式

	向一个现有的对象添加新的功能,又不改变其结构,创建一个装饰类,来包装原来的类,提供额外的功能

	优点:装饰类和被装饰类可以独立发展,不会相互耦合,是继承一个替代模式,动态扩展一个实现类的功能

	缺点:多成装饰复杂

	使用场景:扩展一个类功能,动态增加功能,动态撤销功能

六.代理模式

一个类代表另一个类的功能,创建具有现有对象的对象,便于向外界提供功能接口

为其他对象提供一种代理控制对这个对象的访问,在访问类时做中间层,实现被代理类组合

优点:高扩展性

缺点:请求处理速度变慢

使用场景:远程代理,同步化代理

与适配器的区别:适配器模式主要改变所考虑对象的接口,代理模式不能改变所代理类的接口

与装饰器区别:装饰器模式是为了增强功能,代理模式是为了加以控制

七.策略模式

一个类的行为或者是算法可以在运行的时候更改

定义一系列的算法,一个个封装起来,并可以相互替换,在多种算法相似的情况下,使用if..else所带来的难度

优点:算法可以自由切换,避免使用多重条件判断,扩展性好

缺点:策略类增多,需要对外暴露

使用场景:一个系统中有许多类,区别在于它们的行为,使用策略模式可以动态的让一个对象在许多行为中选择一种行为,一个系统需要动态的在几种算法中选择一种

八.观察者模式

对象间存在一对多关系时,当一个对象被修改时,会自动通知到他的依赖对象

解决了一个对象改变给其他对象通知的问题,考虑到易用和低耦合,保证高度的协作

优点:观察者和被观察者是抽象耦合的,建立一套触发机制

缺点:时间消耗大,系统耗费

使用场景:一个抽象模型有两个方面,其中一个方面依赖于另一个方面,将这些方面封装在独立的对象中使他们可以各自独立的改变和复用,降低对象之间耦合度,创建一种链式触发机制

九.建造者模式

使用多个简单的对象一步一步构建成一个复杂的对象,提供了创建对象的最佳方式

将一个复杂的构建与其表示相分离,使得同样的构建过程可以创建不同的表示,创建和提供实列,Stringbuilder应用了这种模式

优点:建造者独立,易扩展,便于控制细节风险

缺点:产品必须要有共同点,范围有限制,内部变换复杂,产生很多的建造类

使用场景:需要生成的对象具有复杂的数据结构,对象内部属性相互依赖
